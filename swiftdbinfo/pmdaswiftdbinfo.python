from cpmapi import PM_TYPE_U64, PM_INDOM_NULL, PM_SEM_INSTANT, PM_SEM_COUNTER, PM_TYPE_STRING, PM_SEM_DISCRETE
import cpmapi
from pcp.pmapi import pmUnits, pmContext
from pcp.pmda import PMDA, pmdaMetric, pmdaInstid, pmdaIndom
import subprocess
from swift.container.backend import ContainerBroker
import sqlite3
import json
from datetime import datetime, timezone

bucket_dict = {
    '0-1 KB': 1024,
    '0-10 KB': 10240,
    '10-100 KB': 102400,
    '100 KB - 1 MB': 1048576,
    '1 MB - 10 MB': 10485760,
    '10 MB - 25 MB': 26214400,
    '25 MB - 50 MB': 52428800,
    '50 MB - 100 MB': 104857600,
    '100 MB - 500 MB': 524288000,
    '500 MB - 1 GB': 1073741824,
    '1 GB - 5 GB': 5368709120
}

OBJECT_COUNT_QUERY = """SELECT COUNT(*) AS TotalNumberOfObjects
FROM object;"""

kbyteUnits = pmUnits(1, 0, 0, cpmapi.PM_SPACE_KBYTE, 0, 0)
countUnits = pmUnits(0, 0, 1, 0, 0, cpmapi.PM_COUNT_ONE)
zeroUnits = pmUnits(0, 0, 0, 0, 0, 0)

class EtcdPMDA(PMDA):

    def __init__(self, name, domain):
        super().__init__(name, domain)

        self.dbs = {}
        self.dbNames = {}
        self.dbTimes = {}
        self.db_instances = []
        self.db_instances_indom = self.indom(0)
        self.next_id = 0
        self.add_dbs()
        self.add_indom(pmdaIndom(self.db_instances_indom, self.db_instances))
        #self.set_instance(self.simple_instance)
        self.set_fetch(self.simple_fetch)
        self.set_fetch_callback(self.fetch_callback)
        self.set_label_callback(self.simple_label_callback)
        #self.set_label(self.simple_label)
        self.add_metric(name + '.size', pmdaMetric(
            PMDA.pmid(0, 0),
            PM_TYPE_U64,
            self.db_instances_indom,
            PM_SEM_INSTANT,
            kbyteUnits # todo checlk if bytes and not kb
        ))
        self.add_metric(name + '.object.count', pmdaMetric(
            PMDA.pmid(0, 1),
            PM_TYPE_U64,
            self.db_instances_indom,
            PM_SEM_INSTANT,
            countUnits
        ))
        self.add_metric(name + '.object.dist', pmdaMetric(
            PMDA.pmid(0, 2),
            PM_TYPE_STRING,
            self.db_instances_indom,
            PM_SEM_DISCRETE,
            zeroUnits
        ))


    def get_dbs(self):
        command = [
            'find', '/srv', '-type', 'f',
            '(', '-name', '*.sqlite', '-o', '-name', '*.db', '-o', '-name', '*.sqlite3', ')'
        ]
        process = subprocess.Popen(command, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)
        stdout, stderr = process.communicate()
        if process.returncode != 0:
            self.log(f"Error: {stderr}")
        return stdout.splitlines()

    def add_dbs(self):
        try:
            for db in self.get_dbs():
                if "containers" in db:
                    try:
                        c = ContainerBroker(db)
                        d = c.get_info()
                        now = datetime.now(timezone.utc)
                        epoch_timestamp = int(now.timestamp())
                        dbName = d["container"] +  d["account"] + d["hash"]
                        #todo reaplce - to _
                        if dbName not in self.dbNames and "expiring" not in d["account"]:
                            self.dbTimes[self.next_id] = str(epoch_timestamp) + dbName
                            self.dbNames[dbName] = True
                            self.dbs[self.next_id] = db
                            self.db_instances.append(pmdaInstid(int(self.next_id), str(epoch_timestamp) + dbName))
                            #self.add_label(dbName, self.next_id)
                            self.next_id += 1
                    except Exception as e:
                        self.log(str(e))
                        self.log("excepton")
                        self.log(db)
        except:
            self.log("big")


    # def add_label(self, dbname, index):
    #     label = '{%s}' % f'"swiftdb{dbname}":"ok"'
    #     try:
    #         with open(f"/etc/pcp/labels/{index}", 'w') as f:
    #             f.write(label)
    #     except Exception as e:
    #         self.log(f"An error occurred: {e}")

    # def simple_label(self, ident, type):
    #     '''
    #     Return JSONB format labelset for identifier of given type, as a string
    #     '''
    #     if type == cpmapi.PM_LABEL_DOMAIN:
    #        pass
    #         #ret = '"role":"testing"'
    #     elif type == cpmapi.PM_LABEL_INDOM:
    #         indom = ident
    #         if indom == self.db_instances_indom:
    #             pass
    #             #ret = '"indom_name":"time","unitsystem":"SI"'
    #     else: # no labels added for types PM_LABEL_CLUSTER, PM_LABEL_ITEM
    #         ret = '' # default is an empty labelset string
    #     # self.log("simple_label(%#x,%d) returning {%s}" % (ident, type, ret))
    #     #ret = ",".join([f'"swiftdb_{name}":"found"' for name  in self.dbNames.keys()][0:1])
    #     #self.log('{"swiftDBNames": %s}' % str([name for name  in self.dbNames.keys()]))
    #     return '{"swiftDBNames": [%s]}' % ",".join([f'"{name}"' for name  in self.dbNames.keys()])


    def simple_label_callback(self, indom, inst):
        '''
        Return JSONB format labelset for an inst in given indom, as a string
        '''
        self.log("lables")
        if inst in self.dbs.keys():
            timedName = self.dbTimes[inst]
            ret = f'"swift_db_name":"{timedName}"'
            self.log(ret)
        else:
            ret = ''
        return '{%s}' % ret

    def simple_instance(self, serial):
        if serial == 0:
            self.simple_fetch()

    def simple_fetch(self):
        self.add_dbs()
        self.replace_indom(self.db_instances_indom, self.db_instances)

    def get_db_size(self, path: str):
        c = ContainerBroker(path)
        d = c.get_info()
        return [d["bytes_used"], 1]

    def query(self, path, query):
        conn = sqlite3.connect(path, check_same_thread=False)
        res = conn.execute(query)
        rows = res.fetchall()
        conn.close()
        return rows


    def get_object_distrubution(self, path: str):
        self.log(f"dist : {path}")
        result = self.query(path, generate_named_bucket_query(bucket_dict))
        completeResult = {k: 0 for k, _ in bucket_dict.items()}
        for row in result:
            completeResult[row[0]] = row[1]
        return [", ".join(map(lambda a: f"{a[0]}={a[1]}", completeResult.items())), 1]
        #return [json.dumps(completeResult), 1]

    def get_object_count(self, path: str):
        self.log(f"count : {path}")
        result = self.query(path, OBJECT_COUNT_QUERY)
        self.log(f"result:   {result[0][0]}")
        return [result[0][0], 1]

    # item is id of metric is this pdma as set in add metric fucntion
    def fetch_callback(self, cluster, item, inst):
        if inst >= self.next_id:
            return [cpmapi.PM_ERR_INST, 0]
        self.log(f"next id:{self.next_id} len db: {len(self.db_instances)}")
        self.log(f"{cluster} {item} {inst}")
        if (item == 0):
            try:
                path = self.dbs[inst]
                return self.get_db_size(path)
            except Exception as e:
                self.log(str(e))
                return [0, 1]
        if (item == 1):
            try:
                path = self.dbs[inst]
                return self.get_object_count(path)
            except Exception as e:
                self.log(str(e))
                return [0, 1]
        if (item == 2):
            try:
                path = self.dbs[inst]
                return self.get_object_distrubution(path)
            except Exception as e:
                self.log(str(e))
                return ["", 0]
        return [100, 0] # return result and 1 for sucsees 0 for failure



def generate_named_bucket_query(bucket_dict):
    """
    Generate an SQL query to count the number of objects in each named bucket range.

    Parameters:
    - bucket_dict (dict): Dictionary where the key is the bucket name and the value is the upper bound of the bucket range.

    Returns:
    - str: The SQL query string.
    """
    # Initialize the start size for the first bucket
    start = 0

    # Create CASE statements and ORDER BY statements
    case_statements = []
    order_statements = []

    # Iterate through the dictionary to create CASE statements
    for i, (name, upper_bound) in enumerate(bucket_dict.items()):
        # Handle the bucket range with the previous start and the current upper bound
        case_statements.append(f"WHEN size BETWEEN {start} AND {upper_bound} THEN '{name}'")
        order_statements.append(f"WHEN Bucket = '{name}' THEN {i + 1}")
        # Update start for the next bucket range
        start = upper_bound + 1

    # Add an 'else' case for any sizes larger than the largest bucket
    case_statements.append(f"ELSE 'Above {upper_bound}'")

    # Join CASE statements to form the complete CASE block
    case_block = "CASE " + " ".join(case_statements) + " END"

    # Generate the complete SQL query
    query = f"""
SELECT
    {case_block} AS Bucket,
    COUNT(*) AS NumberOfObjects
FROM object
GROUP BY Bucket
ORDER BY
    CASE { ' '.join(order_statements) } ELSE {len(bucket_dict) + 1} END;
"""
    return query


if __name__ == '__main__':
    EtcdPMDA('swiftdbinfo', 400).run()